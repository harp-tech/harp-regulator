using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace Harp.Devices.SetupApi;

// Note: It is intentional that this struct (as well as the ones automatically generated by StronglyTypedHandleDeclaration) do _not_ provide
// equality operators for void* or IntPtr. It turns out having them for void* is somewhat problematic as it causes conflicts with the NullReference
// implicit conversion. After some consideration, I think having `null` be able to work with handles is more valuable than comparing them with typeless pointers.
// The typeless pointers (especially IntPtr) really only ever occur in the .NET API, but it shouldn't be a common scenario for us to interop with them.
// If the situation arises where we need to, we can use the explicit casting operators.
//
// For the sake of posterity: The implicit NullReference conversion enables scenarios like this:
//   CloseHandle(null);
//
// However, having an operator ==(HANDLE, void*) causes issues because given:
//   HANDLE instance = Windows.GetModuleHandle(null);
//   if (instance == null)
//   { throw new Win32Exception(); }
// The if statement is ambiguous between:
//   op_Equal((HANDLE)instance, (void*)null)
// and
//   op_Equal(HANDLE)instance, (HANDLE)op_ImplicitConversionToHANDLE((NullReference)null))
//
// So you can either
// A) Remove the implicit NullReference conversion (Which breaks the CloseHandle example above.)
// B) Remove the op_Equal(HANDLE, void*) (Which is what we went with.)
// C) Remove the implicit NullReference conversion and make the void* conversion implicit. (Which is a dangerous cast.)
//
// One might observe that IntPtr equality is an unecessary casualty in all of this. It was ommitted for symmetry reasons, it could be reintroduced if the need arises.
// Note that the need for the explicit casts should not matter aside from aesthetics as the JIT (should) emit identical code in release builds.
internal unsafe readonly struct HANDLE : IEquatable<HANDLE>
{
    internal readonly void* Value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private HANDLE(void* value)
        => Value = value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator void*(HANDLE handle)
        => handle.Value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator IntPtr(HANDLE handle)
        => (IntPtr)handle.Value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator UIntPtr(HANDLE handle)
        => (UIntPtr)handle.Value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator HANDLE(void* handle)
        => new HANDLE(handle);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator HANDLE(IntPtr handle)
        => new HANDLE((void*)handle);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator HANDLE(UIntPtr handle)
        => new HANDLE((void*)handle);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator HANDLE(NullReference? handle)
        => default;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(HANDLE a, HANDLE b)
        => a.Equals(b);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(HANDLE a, HANDLE b)
        => !a.Equals(b);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals(HANDLE other)
        => this.Value == other.Value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override bool Equals(object? obj)
        => obj is HANDLE other ? Equals(other) : false;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode()
        => ((IntPtr)Value).GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override string ToString()
        => $"HANDLE(0x{((IntPtr)Value).ToString(Environment.Is64BitProcess ? "X16" : "X8")})";

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public HANDLE ThrowIfNull()
    {
        if (Value == null)
        { throw new Win32Exception(); }

        return this;
    }
}
